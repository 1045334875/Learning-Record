# Homework 3

#### 1. Operating System Concepts Chapter 1 Exercises: 1.14, 1.17, 1.19, 1.22 (20 points)

###### 1.14 What is the purpose of interrupts? How does an interrupt differ from a trap? Can traps be generated intentionally by a user program? If so, for what purpose?

The purpose of interrupts throughout modern operating systems is to handle asynchronous events.

Differences:

1. The trap is a signal raised by a user program instructing the operating system to perform some functionality immediately. In contrast, the interrupt is a signal to the CPU emitted by hardware that indicates an event that requires immediate attention.
2. A trap also triggers OS functionality. It gives control to the trap handler. In contrast, an interrupt triggers the CPU to perform the interrupt handler routine.
3. A trap is synchronous and may occur after the execution of the instruction. In contrast, an interrupt is asynchronous and may occur at any time.
4. A trap is generated by a user program instruction. In contrast, the hardware devices generate an interrupt.

Yes, traps can be generated by a user program for instructing the operating system to do some instruction.

###### 1.17 Some computer systems do not provide a privileged mode of operation in hardware. Is it possible to construct a secure operating system for these computer systems? Give arguments both that it is and that it is not possible.

If it is possible:

We can fix some system functions on the hardware and can't be rewritten. The security of the system depends on security of each application. If the programming languages are safe in memory space processing, it's possible to construct a secure operating system.

If it is not possible:

We can't promise all the applications are safe. If there isn't a privileged mode,  malicious programs will rewrite the operating system code and may damage some vital functions of the operating system. 

###### 1.19 Rank the following storage systems from slowest to fastest: 

###### a. Hard-disk drives b. Registers c. Optical disk d. Main memory e. Nonvolatile memory f. Magnetic tapes g. Cache

1. f. Magnetic tapes
2. c. Optical disk
3. a. Hard-disk drive
4. e. Nonvolatile memory
5. d. Main memory
6. g. Cache
7. b. Registers

###### 1.22 Describe a mechanism for enforcing memory protection in order to prevent a program from modifying the memory associated with other programs

Virtual memory can be used as a memory protection tool, which stores the permissions and memory addresses of each process. Kernel and user modes are set in the operating system. The system checks the mode of each process before executing the instruction. When a process attempts to perform some operations beyond its mode, it will trigger the system exception function.

#### 2. Detail your steps about how to get arch/arm64/kernel/sys.i (10 points)

```
 //启动处于停止状态的容器
 $docker start oslab1  //因为我的容器名称叫oslab1
 $docker ps  //查看正在运行的容器，这步用于确定容器正在运行，可以省略
 $docker exec -it oslab1 bash   //将终端连入docker容器(oslab1)
 root@(随机码):/# 
```

![image-20211121002852613](C:\Users\86181\Desktop\image-20211121002852613.png)

直接编译遇到错误，原因是arm架构下要用aarch tool chain。进行一下更新。

**在linux-5.15文件夹路径**下，依次输入以下指令

```
 #apt-get update
#apt-get install gcc-aarch64-linux-gnu
#aarch64-linux-gnu-gcc -v //查看gcc版本，如果有版本信息，这说明添加成功
#make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig//生成配置
/*这里会输出
***Default configuration is based on 'defconfig'
#
# configuration written to .config
#
以上这四行*/

#apt-get install libssl-dev
#make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- arch/arm64/kernel/sys.i -j $(nproc) //编译 
//nproc内核参数,是系统上的最大进程数。使用多线程编译一般会耗费大量内存，如果 -j 选项导致内存耗尽 (out of memory)，请尝试调低线程数c'd，比如 -j4, -j8 等。
```

#### 3. Find system call table of Linux v5.15 for ARM32, RISC-V(32 bit), RISC-V(64 bit), x86(32 bit), x86_64 (50 points)

List source code file, the whole system call table with macro expanded, screenshot every step.

```
进入oslab1容器的linux-5.15文件夹
#find / -name 'syscall*' //一定要加*不然会报错
```

![image-20211125131628882](C:\Users\86181\Desktop\image-20211125131628882.png)

然后我们得到了所有文件名包含syscall的文件，在一共166个文件中我们可以发现几个有用的。

```
- /have-fun-debugging/linux-5.15/arch/riscv/kernel/syscall_table.c
- /have-fun-debugging/linux-5.15/arch/x86/entry/syscalls/syscall_64.tbl
- /have-fun-debugging/linux-5.15/arch/x86/entry/syscalls/syscall_32.tbl
- /have-fun-debugging/linux-5.15/arch/arm/tools/syscall.tbl
```

.tbl文件可直接在terminal里通过cat指令查看，下面三个都可以这样看到system call table，.c文件则需要通过编译获得。以下为实验截图：

- /have-fun-debugging/linux-5.15/arch/arm/tools/syscall.tbl

<img src="C:\Users\86181\Desktop\image-20211125133141452.png" alt="image-20211125133141452" style="zoom:67%;" />

<img src="C:\Users\86181\Desktop\image-20211125133205830.png" alt="image-20211125133205830" style="zoom:67%;" />

<img src="C:\Users\86181\Desktop\image-20211125133257554.png" alt="image-20211125133257554" style="zoom:67%;" />

- /have-fun-debugging/linux-5.15/arch/x86/entry/syscalls/syscall_32.tbl

<img src="C:\Users\86181\Desktop\image-20211125133416865.png" alt="image-20211125133416865" style="zoom:67%;" />

<img src="C:\Users\86181\Desktop\image-20211125133444863.png" alt="image-20211125133444863" style="zoom:67%;" />

<img src="C:\Users\86181\Desktop\image-20211125133512085.png" alt="image-20211125133512085" style="zoom:67%;" />

共计448个系统调用函数表

- /have-fun-debugging/linux-5.15/arch/x86/entry/syscalls/syscall_64.tbl

  <img src="C:\Users\86181\Desktop\image-20211125133708068.png" alt="image-20211125133708068" style="zoom:67%;" />

  <img src="C:\Users\86181\Desktop\image-20211125133835218.png" alt="image-20211125133835218" style="zoom:67%;" />

  <img src="C:\Users\86181\Desktop\image-20211125133851551.png" alt="image-20211125133851551" style="zoom:67%;" />

  共计547个系统调用函数

- /have-fun-debugging/linux-5.15/arch/riscv/kernel/syscall_table.c

在riscv文件夹中，只有这一个syscall_table.c函数记录了系统函数调用表。在64位和32位不同编译器中编出的汇编语言可能不一样，但其函数调用表的序号和函数是一样的，故在此只展示出64位riscv64-unknown-linux-gnu-gcc编译出的系统调用表。

```
#make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- arch/riscv/kernel/syscall_table.i -j$(nproc)
这里要注意中间是.i不是.c，中间是目标文件
```

<img src="C:\Users\86181\Desktop\image-20211125151007027.png" alt="image-20211125151007027" style="zoom:67%;" />

<img src="C:\Users\86181\Desktop\image-20211125151846487.png" alt="image-20211125151846487" style="zoom:67%;" />

#### 4.Explain what is ELF file? Try readelf and objdump command on an ELF file, give screenshot of the output.

**Run an ELF file and cat /proc/PID/maps to give its memory layout.** 

Executable and Linkable Format. It is a common standard file format for executable files, object code, shared libraries, and core dumps.

```
#touch test.c  //新建test.c
#vi test.c  //进入编辑test.c
Esc + :exit  //退出编辑
#gcc test.c  //没有规定文件名称，默认生成了a.out
#readelf -a a.out //all显示全部信息，等价于-h-l-S-s-r-d-V-A-I
```

##### readelf 只能看elf文件的信息

- **选项-h(elfheader)，显示elf文件开始的文件头信息。后面文章会补上具体说明。**
- **选项-l(programheaders)，segments显示程序头（段头）信息(如果有数据的话)。后面文章会补上具体说明。**
- **选项-S(sectionheaders)，sections显示节头信息(如果有数据的话)。后面文章会补上具体说明。**
- 选项-a，all显示全部信息，等价于-h-l-S-s-r-d-V-A-I。
- 选项-g(sectiongroups)，显示节组信息(如果有数据的话)。
- 选项-t，section-details显示节的详细信息(-S的)。
- 选项-s，symbols显示符号表段中的项（如果有数据的话）。
- 选项-e，headers显示全部头信息，等价于:-h-l-S。
- 选项-n，notes显示note段（内核注释）的信息。
- 选项-r，relocs显示可重定位段的信息。
- 选项-u，unwind显示unwind段信息。当前只支持IA64ELF的unwind段信息。
- 选项-d，dynamic显示动态段的信息。
- 选项-V，version-info显示版本段的信息。
- 选项-A，arch-specific显示CPU构架信息。
- 选项-I，histogram显示符号的时候，显示bucketlist长度的柱状图。
- 选项-x,hex-dump=以16进制方式显示指定段内内容。number指定段表中段的索引，或字符串指定文件中的段名
- 选项-D，use-dynamic使用动态段中的符号表显示符号，而不是使用符号段。
- 选项-v，version显示readelf的版本信息。
- 选项-H，help显示readelf所支持的命令行选项。

<img src="C:\Users\86181\Desktop\image-20211125141959802.png" alt="image-20211125141959802" style="zoom:67%;" />

<img src="C:\Users\86181\Desktop\image-20211125142018551.png" alt="image-20211125142018551" style="zoom:67%;" />

<img src="C:\Users\86181\Desktop\image-20211125142307935.png" alt="image-20211125142307935" style="zoom:67%;" />

（后信息省略）

#### odjdump

```
objdump -d a.out //-d 参数看代码段反汇编结果
objdump -t a.out //显示文件的符号表入口。
objdump -t libc.a grep -w printf //查找 printf 在 libc.a 库的哪个目标文件
objdump -h simple.o //显示目标文件各个section的头部摘要信息
objdump -r simple.o //查看重定位表
objdump -f simple.o //显示objfile中每个文件的整体头部摘要信息
objdump -s simple.o //显示指定section的完整内容
objdump -x simple.o //显示所可用的头信息
objdump -a simple.o //显示档案库的成员信息
```

反汇编结果如下

<img src="C:\Users\86181\Desktop\image-20211125143057390.png" alt="image-20211125143057390" style="zoom:67%;" />

符号表入口

<img src="C:\Users\86181\Desktop\image-20211125143240808.png" alt="image-20211125143240808" style="zoom:67%;" />

#### **Run an ELF file and cat /proc/PID/maps to give its memory layout.** 

<img src="C:\Users\86181\Desktop\image-20211126172927826.png" alt="image-20211126172927826" style="zoom:67%;" />

```
#ps aux |grep pmap //查看程序pid
```

可以看到程序pmap的pid为3082，但是这个程序运行结束后，它所分配的内存也被回收了，所以在下一步搜索中并看不到/3082/maps。此时文件夹中并没有/proc路径，但是经过搜索我们可以看到这个路径是在系统根目录下的。

<img src="C:\Users\86181\Desktop\image-20211126173639315.png" alt="image-20211126173639315" style="zoom:67%;" />

通过查找可以发现有这几个进程。其中3087为terminal窗口执行每一条指令的进程，每输入一条指令该数都会增加，查询指令对应的进程号是3087，在此次查询结束后是无法通过cat /proc/3087/maps访问到的。故选择进程3039进行查看。

可以看到其中每个进程运行的：

- address: 0085d000-00872000 虚拟内存区域的起始和终止地址文件所占的地址空间
- perms:rw-p 权限：r=read, w=write, x=execute, s=shared, p=private(copy on write)
- offset: 00000000 虚拟内存区域在被映射文件中的偏移量
- dev: 03:08 文件的主设备号和次设备号
- inode: 设备的节点号，0表示没有节点与内存相对应
- name: /lib/ld-2.2.12.so 被映射文件的文件名

<img src="C:\Users\86181\Desktop\image-20211126174348481.png" style="zoom:67%;" />

<img src="C:\Users\86181\Desktop\image-20211126174410508.png" alt="image-20211126174410508" style="zoom:67%;" />



**2, 3, 4 need to have screenshots.** 



 